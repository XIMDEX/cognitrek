<?php

namespace Modules\LlmModule\Services\Adapters;

use App\Http\Services\Http\HttpClientService;
use App\Jobs\ProcessManualBatchJob;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;


abstract class LLMBaseAdapter
{
    protected $apiKey;
    protected $baseUrl;
    protected $model;
    protected $httpClient;
    protected $endpoints;

    const STATUS_ERROR = [
        1 => 'FAILED',
        2 => 'TIMEOUT',
        3 => 'FILE_NOT_FOUND',
    ];

    const STATUS_FILE_UPLOAD_OK = 'processed';
    const STATUS_OK = 'ok';

    /**
     * @param string $apiKey
     * @param string $baseUrl
     * @param string $model
     * @param HttpClientService $httpClient
     */
    public function __construct($apiKey, $baseUrl, $model, HttpClientService $httpClient)
    {
        $this->apiKey = $apiKey;
        $this->baseUrl = rtrim($baseUrl, '/');
        $this->httpClient = $httpClient;
        $this->model = $model;
        $this->endpoints = [
            'chat' => '/v1/chat/completions',
            'files' => false,
            'batches' => false,
        ];
    }

    /**
     * Public method that each adapter must implement to make a call to the LLM.
     *
     * @param string $prompt
     * @param array  $options Additional options specific to each model (max_tokens, model, etc.)
     * @param string $path
     * @return string The response generated by the LLM
     * 
     */
    public function call($prompt, array $options = [], $path=null): string
    {
        if ($path === null) {
            $path =  $this->baseUrl . $this->endpoints['chat'];
        }
        $model = $this->model;

        $opts = [
            'headers' => [
                'Content-Type'  => 'application/json',
            ],
            'json' => [
                'model' => $model,
                'messages' => [
                    ['role' => 'system', 'content' => $prompt]
                ],
                // 'prompt' => $prompt,
                "options" => [
                    "num_ctx" => 10000,
                    'temperature' => $options['temperature'] ?? 1,
                    'max_tokens' => $options['max_tokens'] ?? 10000,
                    "num_ctx" => $options['max_tokens'] ?? 10000,
                    "context_length"=> 8192,
                    "limit" => $options['max_tokens'] ?? 10000,
                    'top_p' => $options['top_p'] ?? 1,
                    'frequency_penalty' => $options['frequency_penalty'] ?? 0,
                    'presence_penalty' => $options['presence_penalty'] ?? 0
                ],
                'temperature' => $options['temperature'] ?? 1,
                'max_tokens' => $options['max_tokens'] ?? 10000,
                "num_ctx" => $options['max_tokens'] ?? 10000,
                "context_length"=> 8192,
                "limit" => $options['max_tokens'] ?? 10000,
                'top_p' => $options['top_p'] ?? 1,
                'frequency_penalty' => $options['frequency_penalty'] ?? 0,
                'presence_penalty' => $options['presence_penalty'] ?? 0
            ]
        ];

        if ($this->apiKey) {
            $opts['headers']['Authorization'] = 'Bearer ' . $this->apiKey;
        }

        $response = $this->httpClient->request('POST', $path, $opts);

        return $response['choices'][0]['message']['content'] ?? '';
    }


    /**
     * Public method that each adapter must implement to make a batch call to the LLM.
     * 
     * @param array $prompts
     * @param array $options
     * @return array The responses generated by the LLM
     */
    public function batch(array $data, $prompt = "###XIMDEX_CONTENT###" ,  array $options = []): array 
    {
        try {            
            $output = ['id' => false, 'content' => [], 'error'   => false, 'batch' => 'internal'];
            $batchId = $options['batch_id'] ?? null;
    
            $options['llm_manager']['adapter'] = self::class;
    
            if (!$batchId) {
                $batchId = (string) Str::uuid();
                $output['id'] = $batchId;
    
                $folderPath = "public/adaptations_batches/{$batchId}";
                Storage::makeDirectory($folderPath);
    
                $tempFilePath = $this->createJsonlFile($data, $prompt, $options);
    
                $batchFilePath = $folderPath . "/batch.jsonl";
                Storage::put($batchFilePath, file_get_contents($tempFilePath));
                @unlink($tempFilePath);
    
                Storage::put("{$folderPath}/output.json", json_encode([], JSON_PRETTY_PRINT));
    
                ProcessManualBatchJob::dispatch($batchId, $options);
    
                return $output;
            }
    
            $folderPath = "public/adaptations_batches/{$batchId}";
            if (!Storage::exists($folderPath.'/output.json')) {
                $output['error']   = true;
                $output['content'] = ['message' => 'Batch not found or invalid.'];
                return $output;
            }
    
            $results = json_decode(Storage::get($folderPath.'/output.json'), true);
            $output['id']      = $batchId;
            $output['content'] = $results;
    
            return $output;
        } catch (\Throwable $th) {
            throw $th;
        }
    }

    public function checkBatchStatus(string $batchId): string
    {
        $folderPath = "public/adaptations_batches/{$batchId}";
        $batchFile  = $folderPath . '/batch.jsonl';
        $outputFile = $folderPath . '/output.json';

        if (!Storage::exists($batchFile) || !Storage::exists($outputFile)) {
            return self::STATUS_ERROR[3];
        }

        $lines      = explode("\n", trim(Storage::get($batchFile)));
        $totalLines = count(array_filter($lines)); 
        $outputData = json_decode(Storage::get($outputFile), true);
        $processed  = count($outputData ?? []);

        if ($processed >= $totalLines) {
            return $outputFile;
        } else {
            return self::STATUS_ERROR[2];
        }
    }

    private function downloadBatchResults(string $batchId)
    {
        $folderPath = "public/adaptations_batches/{$batchId}";
        $outputFile = $folderPath . '/output.json';

        if (!Storage::exists($outputFile)) {
            return [
                'status'  => self::STATUS_ERROR[3],
                'message' => 'Output file not found',
                'data'    => []
            ];
        }

        $data = json_decode(Storage::get($outputFile), true);
        return [
            'status' => self::STATUS_OK,
            'data'   => $data ?? []
        ];
    }

    public function deleteBatch(string $batchId)
    {
        $folderPath = "public/adaptations_batches/{$batchId}";
        if (Storage::exists($folderPath)) {
            Storage::deleteDirectory($folderPath);
            return true;
        }
        throw new \Exception('Failed to delete batch with ID: ' . $batchId);
    }

    public function deleteBatchAndFile(string $batchId)
    {
        return $this->deleteBatch($batchId);
    }



    /**
     * Public method that each adapter must implement to make a batch call to the LLM.
     * 
     * @param array $prompts
     * @param array $options
     * @return array The responses generated by the LLM
     */
    public function _batch(array $prompts, array $options = []): array 
    {
        $output = ['id' => false, 'content' => []];
        $outputFileId = false;
        $batchId = $data['batch_id'] ?? false;

        try {
            
        } catch (\Throwable $th) {
            if (!$batchId) {

            }
        }
        return [];
    }

    /**
     * Generates a temporary JSONL file for batch processing requests to the LLM.
     *
     * @param array $data An array of associative arrays containing 'id' and 'content' keys.
     * @param string $prompt The template prompt with a placeholder for content insertion.
     * @param array $options Optional parameters for model configuration (temperature, max_tokens, etc.).
     * @return string The file path of the generated temporary JSONL file.
     */
    protected function createJsonlFile(array $data, $prompt, array $options): string
    {
        $tempFile = tempnam(sys_get_temp_dir(), 'batch_') . '.jsonl';
        $fileHandle = fopen($tempFile, 'w');

        foreach ($data as $item) {
            $data_prompt = str_replace('###XIMDEX_CONTENT###', $item['content'], $prompt);
            $body = [
                'model' => $this->model,
                'messages' => [
                    ['role' => 'system', 'content' => $data_prompt]
                ],
            ];
            $requestBody = [
                'custom_id' => "{$item['id']}",
                'method' => 'POST',
                'url' => $this->endpoints['chat'],
                'body' => array_merge($body, $options)
            ];

            fwrite($fileHandle, json_encode($requestBody) . "\n");
        }

        fclose($fileHandle);

        return $tempFile;
    }

}
